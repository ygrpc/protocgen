package main

import (
	"fmt"
	"log"
	"os"
	"slices"
	"strings"

	"github.com/ygrpc/protocgen/protocplugin"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	logPrefix := "protoc-gen-ygrpc-cgo: "
	log.SetPrefix(logPrefix)

	_, _, err := protocplugin.ProtoGeneratorMain(protocCgoHandler, os.Stdin, os.Stdout, logPrefix)
	if err != nil {
		log.Fatalf("error: failed to execute protoc plugin handler: %v", err)
	}
}

func protocCgoHandler(request *pluginpb.CodeGeneratorRequest) (genFiles []*pluginpb.CodeGeneratorResponse_File) {
	for _, fd := range request.GetProtoFile() {
		if !slices.Contains(request.FileToGenerate, fd.GetName()) {
			continue
		}

		originalFile := fd.GetName()
		originalFilenameOnly := protocplugin.ExtractFilename(originalFile)
		goOutName := "ygrpc_cgo/" + originalFilenameOnly + ".ygrpc.cgo.go"

		goContent := buildBinaryUnaryGoFile(fd)

		genFiles = append(genFiles, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(goOutName),
			Content: proto.String(goContent),
		})
	}

	return genFiles
}

func buildBinaryUnaryGoFile(fd *descriptorpb.FileDescriptorProto) string {
	b := &strings.Builder{}

	fmt.Fprintf(b, "//go:build ygrpc_cgo\n")
	fmt.Fprintf(b, "// Code generated by protoc-gen-ygrpc-cgo. DO NOT EDIT.\n")
	fmt.Fprintf(b, "// source: %s\n\n", fd.GetName())

	fmt.Fprintf(b, "package main\n\n")

	fmt.Fprintf(b, "/*\n")
	fmt.Fprintf(b, "#include <stdlib.h>\n\n")
	fmt.Fprintf(b, "typedef void (*FreeFunc)(void*);\n\n")
	fmt.Fprintf(b, "// NOTE: This generator intentionally avoids C structs for ABI stability.\n")
	fmt.Fprintf(b, "// All bytes/string values use the (ptr, len, free) triple in function parameters.\n")
	fmt.Fprintf(b, "*/\n")
	fmt.Fprintf(b, "import \"C\"\n")
	fmt.Fprintf(b, "import \"unsafe\"\n\n")

	for _, svc := range fd.GetService() {
		serviceName := svc.GetName()
		for _, m := range svc.GetMethod() {
			if m.GetClientStreaming() || m.GetServerStreaming() {
				continue
			}

			funcName := serviceName + "_" + m.GetName()
			reqType := strings.TrimPrefix(m.GetInputType(), ".")
			respType := strings.TrimPrefix(m.GetOutputType(), ".")
			reqMsg := reqType
			respMsg := respType
			if dot := strings.LastIndex(reqType, "."); dot != -1 {
				reqMsg = reqType[dot+1:]
			}
			if dot := strings.LastIndex(respType, "."); dot != -1 {
				respMsg = respType[dot+1:]
			}

			fmt.Fprintf(b, "// %s is the Binary Mode (protobuf bytes) entrypoint for:\n", funcName)
			fmt.Fprintf(b, "//   rpc %s(%s) returns (%s);\n", m.GetName(), reqType, respType)
			fmt.Fprintf(b, "//\n")
			fmt.Fprintf(b, "// ABI (no C structs):\n")
			fmt.Fprintf(b, "//   - bytes are passed as a (ptr, len, free) triple.\n")
			fmt.Fprintf(b, "//   - %s* contains serialized %s protobuf bytes.\n", reqMsg, reqType)
			fmt.Fprintf(b, "//   - %s* must be set to serialized %s protobuf bytes.\n", respMsg, respType)
			fmt.Fprintf(b, "//\n")
			fmt.Fprintf(b, "// Return:\n")
			fmt.Fprintf(b, "//   - 0 on success; non-zero on failure.\n")
			fmt.Fprintf(b, "//export %s\n", funcName)
			fmt.Fprintf(
				b,
				"func %s(%sPtr unsafe.Pointer, %sLen C.int, %sFree C.FreeFunc, %sPtr *unsafe.Pointer, %sLen *C.int, %sFree *C.FreeFunc) C.int {\n",
				funcName,
				reqMsg,
				reqMsg,
				reqMsg,
				respMsg,
				respMsg,
				respMsg,
			)
			fmt.Fprintf(b, "\t_ = %sPtr\n", reqMsg)
			fmt.Fprintf(b, "\t_ = %sLen\n", reqMsg)
			fmt.Fprintf(b, "\t_ = %sFree\n", reqMsg)
			fmt.Fprintf(b, "\tif %sPtr != nil {\n\t\t*%sPtr = nil\n\t}\n", respMsg, respMsg)
			fmt.Fprintf(b, "\tif %sLen != nil {\n\t\t*%sLen = 0\n\t}\n", respMsg, respMsg)
			fmt.Fprintf(b, "\tif %sFree != nil {\n\t\t*%sFree = nil\n\t}\n", respMsg, respMsg)
			fmt.Fprintf(b, "\treturn 0\n")
			fmt.Fprintf(b, "}\n\n")
		}
	}

	fmt.Fprintf(b, "// main is required when building with -buildmode=c-shared / c-archive.\n")
	fmt.Fprintf(b, "// It is intentionally empty.\n")
	fmt.Fprintf(b, "func main() {}\n")

	return b.String()
}
