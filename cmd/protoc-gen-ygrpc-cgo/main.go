package main

import (
	"fmt"
	"log"
	"os"
	"slices"
	"strings"

	"github.com/ygrpc/protocgen/protocplugin"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	logPrefix := "protoc-gen-ygrpc-cgo: "
	log.SetPrefix(logPrefix)

	_, _, err := protocplugin.ProtoGeneratorMain(protocCgoHandler, os.Stdin, os.Stdout, logPrefix)
	if err != nil {
		log.Fatalf("error: failed to execute protoc plugin handler: %v", err)
	}
}

func protocCgoHandler(request *pluginpb.CodeGeneratorRequest) (genFiles []*pluginpb.CodeGeneratorResponse_File) {
	filesToGenerate := make([]*descriptorpb.FileDescriptorProto, 0)
	for _, fd := range request.GetProtoFile() {
		if !slices.Contains(request.FileToGenerate, fd.GetName()) {
			continue
		}
		filesToGenerate = append(filesToGenerate, fd)
	}

	if len(filesToGenerate) == 0 {
		return nil
	}

	// Emit runtime once per invocation, separate from per-proto entrypoints.
	runtimeOutName := "ygrpc_cgo/ygrpc_runtime.go"
	genFiles = append(genFiles, &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(runtimeOutName),
		Content: proto.String(buildBinaryUnaryRuntimeGoFile()),
	})

	for _, fd := range filesToGenerate {
		originalFile := fd.GetName()
		originalFilenameOnly := protocplugin.ExtractFilename(originalFile)
		goOutName := "ygrpc_cgo/" + originalFilenameOnly + ".ygrpc.cgo.go"

		goContent := buildBinaryUnaryProtoGoFile(fd)
		genFiles = append(genFiles, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(goOutName),
			Content: proto.String(goContent),
		})
	}

	return genFiles
}

func buildBinaryUnaryRuntimeGoFile() string {
	b := &strings.Builder{}

	fmt.Fprintf(b, "// Code generated by protoc-gen-ygrpc-cgo. DO NOT EDIT.\n")
	fmt.Fprintf(b, "// source: ygrpc_runtime\n\n")

	fmt.Fprintf(b, "package main\n\n")

	fmt.Fprintf(b, "/*\n")
	fmt.Fprintf(b, "#include <stdlib.h>\n\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "typedef void (*FreeFunc)(void*);\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "static FreeFunc ygrpc_get_free_func(void) { return free; }\n")
	fmt.Fprintf(b, "*/\n")
	fmt.Fprintf(b, "import \"C\"\n")

	fmt.Fprintf(b, "import (\n")
	fmt.Fprintf(b, "\t\"sync\"\n")
	fmt.Fprintf(b, "\t\"sync/atomic\"\n")
	fmt.Fprintf(b, "\t\"time\"\n")
	fmt.Fprintf(b, "\t\"unsafe\"\n")
	fmt.Fprintf(b, ")\n\n")

	fmt.Fprintf(b, "type ygrpcErrorEntry struct {\n")
	fmt.Fprintf(b, "\tmsg []byte\n")
	fmt.Fprintf(b, "\texpiresAt time.Time\n")
	fmt.Fprintf(b, "}\n\n")
	fmt.Fprintf(b, "var (\n")
	fmt.Fprintf(b, "\tygrpcErrMu sync.Mutex\n")
	fmt.Fprintf(b, "\tygrpcErrNextID uint32\n")
	fmt.Fprintf(b, "\tygrpcErrMap = map[uint32]ygrpcErrorEntry{}\n")
	fmt.Fprintf(b, ")\n\n")

	fmt.Fprintf(b, "func ygrpcStoreError(msg []byte) C.int {\n")
	fmt.Fprintf(b, "\tif len(msg) == 0 {\n")
	fmt.Fprintf(b, "\t\treturn 0\n")
	fmt.Fprintf(b, "\t}\n\n")
	fmt.Fprintf(b, "\tid := atomic.AddUint32(&ygrpcErrNextID, 1)\n")
	fmt.Fprintf(b, "\tif id == 0 {\n")
	fmt.Fprintf(b, "\t\tid = atomic.AddUint32(&ygrpcErrNextID, 1)\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Lock()\n")
	fmt.Fprintf(
		b,
		"\tygrpcErrMap[id] = ygrpcErrorEntry{msg: append([]byte(nil), msg...), expiresAt: time.Now().Add(3 * time.Second)}\n",
	)
	fmt.Fprintf(b, "\tygrpcErrMu.Unlock()\n")
	fmt.Fprintf(b, "\treturn C.int(id)\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "func ygrpcLookupError(id uint32) ([]byte, bool) {\n")
	fmt.Fprintf(b, "\tif id == 0 {\n\t\treturn nil, false\n\t}\n")
	fmt.Fprintf(b, "\tnow := time.Now()\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Lock()\n")
	fmt.Fprintf(b, "\tentry, ok := ygrpcErrMap[id]\n")
	fmt.Fprintf(b, "\tif ok && now.After(entry.expiresAt) {\n")
	fmt.Fprintf(b, "\t\tdelete(ygrpcErrMap, id)\n")
	fmt.Fprintf(b, "\t\tok = false\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Unlock()\n")
	fmt.Fprintf(b, "\tif !ok {\n\t\treturn nil, false\n\t}\n")
	fmt.Fprintf(b, "\treturn entry.msg, true\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "// Ygrpc_GetErrorMsg returns 0 when found, or 1 when not found/expired.\n")
	fmt.Fprintf(b, "//export Ygrpc_GetErrorMsg\n")
	fmt.Fprintf(
		b,
		"func Ygrpc_GetErrorMsg(errorID C.int, msgPtr *unsafe.Pointer, msgLen *C.int, msgFree *C.FreeFunc) C.int {\n",
	)
	fmt.Fprintf(b, "\tif msgPtr != nil {\n\t\t*msgPtr = nil\n\t}\n")
	fmt.Fprintf(b, "\tif msgLen != nil {\n\t\t*msgLen = 0\n\t}\n")
	fmt.Fprintf(b, "\tif msgFree != nil {\n\t\t*msgFree = nil\n\t}\n")
	fmt.Fprintf(b, "\tif errorID == 0 {\n\t\treturn 1\n\t}\n")
	fmt.Fprintf(b, "\tmsg, ok := ygrpcLookupError(uint32(errorID))\n")
	fmt.Fprintf(b, "\tif !ok {\n\t\treturn 1\n\t}\n")
	fmt.Fprintf(b, "\tif msgLen != nil {\n\t\t*msgLen = C.int(len(msg))\n\t}\n")
	fmt.Fprintf(b, "\tif msgPtr != nil {\n")
	fmt.Fprintf(b, "\t\tbuf := C.CBytes(msg)\n")
	fmt.Fprintf(b, "\t\t*msgPtr = buf\n")
	fmt.Fprintf(b, "\t\tif msgFree != nil {\n\t\t\t*msgFree = C.ygrpc_get_free_func()\n\t\t}\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\treturn 0\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "// main is required when building with -buildmode=c-shared / c-archive.\n")
	fmt.Fprintf(b, "// It is intentionally empty.\n")
	fmt.Fprintf(b, "func main() {}\n")

	return b.String()
}

func buildBinaryUnaryProtoGoFile(fd *descriptorpb.FileDescriptorProto) string {
	b := &strings.Builder{}

	fmt.Fprintf(b, "// Code generated by protoc-gen-ygrpc-cgo. DO NOT EDIT.\n")
	fmt.Fprintf(b, "// source: %s\n\n", fd.GetName())

	fmt.Fprintf(b, "package main\n\n")

	fmt.Fprintf(b, "/*\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "typedef void (*FreeFunc)(void*);\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "*/\n")
	fmt.Fprintf(b, "import \"C\"\n")
	fmt.Fprintf(b, "import \"unsafe\"\n\n")

	for _, svc := range fd.GetService() {
		serviceName := svc.GetName()
		for _, m := range svc.GetMethod() {
			if m.GetClientStreaming() || m.GetServerStreaming() {
				continue
			}

			funcName := serviceName + "_" + m.GetName()
			reqType := strings.TrimPrefix(m.GetInputType(), ".")
			respType := strings.TrimPrefix(m.GetOutputType(), ".")
			reqMsg := reqType
			respMsg := respType
			if dot := strings.LastIndex(reqType, "."); dot != -1 {
				reqMsg = reqType[dot+1:]
			}
			if dot := strings.LastIndex(respType, "."); dot != -1 {
				respMsg = respType[dot+1:]
			}

			fmt.Fprintf(b, "// %s is the Binary Mode (protobuf bytes) entrypoint for:\n", funcName)
			fmt.Fprintf(b, "//   rpc %s(%s) returns (%s);\n", m.GetName(), reqType, respType)
			fmt.Fprintf(b, "//\n")
			fmt.Fprintf(b, "// ABI (no C structs):\n")
			fmt.Fprintf(b, "//   - Response bytes are returned as a (ptr, len, free) triple.\n")
			fmt.Fprintf(b, "//   - Request bytes are passed as a (ptr, len) pair by default.\n")
			fmt.Fprintf(
				b,
				"//   - %sPtr/%sLen contains serialized %s protobuf bytes.\n",
				reqMsg,
				reqMsg,
				reqType,
			)
			fmt.Fprintf(
				b,
				"//   - %sPtr/%sLen/%sFree must be set to serialized %s protobuf bytes (output params).\n",
				respMsg,
				respMsg,
				respMsg,
				respType,
			)
			fmt.Fprintf(b, "//\n")
			fmt.Fprintf(b, "// Return:\n")
			fmt.Fprintf(b, "//   - 0 on success; non-zero is an errorId.\n")
			fmt.Fprintf(b, "//\n")
			fmt.Fprintf(b, "// Error reporting:\n")
			fmt.Fprintf(b, "//   - Use Ygrpc_GetErrorMsg(errorId, ...) within 3s to fetch the message.\n")

			fmt.Fprintf(b, "//export %s\n", funcName)
			fmt.Fprintf(
				b,
				"func %s(%sPtr unsafe.Pointer, %sLen C.int, %sPtr *unsafe.Pointer, %sLen *C.int, %sFree *C.FreeFunc) C.int {\n",
				funcName,
				reqMsg,
				reqMsg,
				respMsg,
				respMsg,
				respMsg,
			)
			fmt.Fprintf(b, "\t_ = %sPtr\n", reqMsg)
			fmt.Fprintf(b, "\t_ = %sLen\n", reqMsg)
			fmt.Fprintf(b, "\tif %sPtr != nil {\n\t\t*%sPtr = nil\n\t}\n", respMsg, respMsg)
			fmt.Fprintf(b, "\tif %sLen != nil {\n\t\t*%sLen = 0\n\t}\n", respMsg, respMsg)
			fmt.Fprintf(b, "\tif %sFree != nil {\n\t\t*%sFree = nil\n\t}\n", respMsg, respMsg)
			fmt.Fprintf(b, "\treturn 0\n")
			fmt.Fprintf(b, "}\n\n")
		}
	}

	return b.String()
}
