package main

import (
	"fmt"
	"log"
	"os"
	"slices"
	"strings"

	"github.com/ygrpc/protocgen/protocplugin"
	"google.golang.org/protobuf/encoding/protowire"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	logPrefix := "protoc-gen-ygrpc-cgo: "
	log.SetPrefix(logPrefix)

	_, _, err := protocplugin.ProtoGeneratorMain(protocCgoHandler, os.Stdin, os.Stdout, logPrefix)
	if err != nil {
		log.Fatalf("error: failed to execute protoc plugin handler: %v", err)
	}
}

func protocCgoHandler(request *pluginpb.CodeGeneratorRequest) (genFiles []*pluginpb.CodeGeneratorResponse_File) {
	msgIndex := buildMessageIndex(request.GetProtoFile())

	filesToGenerate := make([]*descriptorpb.FileDescriptorProto, 0)
	for _, fd := range request.GetProtoFile() {
		if !slices.Contains(request.FileToGenerate, fd.GetName()) {
			continue
		}
		filesToGenerate = append(filesToGenerate, fd)
	}

	if len(filesToGenerate) == 0 {
		return nil
	}

	// Emit runtime once per invocation, separate from per-proto entrypoints.
	runtimeOutName := "ygrpc_cgo/ygrpc_runtime.go"
	genFiles = append(genFiles, &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(runtimeOutName),
		Content: proto.String(buildBinaryUnaryRuntimeGoFile()),
	})

	for _, fd := range filesToGenerate {
		originalFile := fd.GetName()
		originalFilenameOnly := protocplugin.ExtractFilename(originalFile)
		goOutName := "ygrpc_cgo/" + originalFilenameOnly + ".ygrpc.cgo.go"

		goContent := buildBinaryUnaryProtoGoFile(fd, msgIndex)
		genFiles = append(genFiles, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(goOutName),
			Content: proto.String(goContent),
		})
	}

	return genFiles
}

func buildBinaryUnaryRuntimeGoFile() string {
	b := &strings.Builder{}

	fmt.Fprintf(b, "// Code generated by protoc-gen-ygrpc-cgo. DO NOT EDIT.\n")
	fmt.Fprintf(b, "// source: ygrpc_runtime\n\n")

	fmt.Fprintf(b, "package main\n\n")

	fmt.Fprintf(b, "/*\n")
	fmt.Fprintf(b, "#include <stdlib.h>\n\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "typedef void (*FreeFunc)(void*);\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "static FreeFunc ygrpc_get_free_func(void) { return free; }\n")
	fmt.Fprintf(b, "*/\n")
	fmt.Fprintf(b, "import \"C\"\n")

	fmt.Fprintf(b, "import (\n")
	fmt.Fprintf(b, "\t\"sync\"\n")
	fmt.Fprintf(b, "\t\"sync/atomic\"\n")
	fmt.Fprintf(b, "\t\"time\"\n")
	fmt.Fprintf(b, "\t\"unsafe\"\n")
	fmt.Fprintf(b, ")\n\n")

	fmt.Fprintf(b, "type ygrpcErrorEntry struct {\n")
	fmt.Fprintf(b, "\tmsg []byte\n")
	fmt.Fprintf(b, "\texpiresAt time.Time\n")
	fmt.Fprintf(b, "}\n\n")
	fmt.Fprintf(b, "var (\n")
	fmt.Fprintf(b, "\tygrpcErrMu sync.Mutex\n")
	fmt.Fprintf(b, "\tygrpcErrNextID uint32\n")
	fmt.Fprintf(b, "\tygrpcErrMap = map[uint32]ygrpcErrorEntry{}\n")
	fmt.Fprintf(b, ")\n\n")

	fmt.Fprintf(b, "func ygrpcStoreError(msg []byte) C.int {\n")
	fmt.Fprintf(b, "\tif len(msg) == 0 {\n")
	fmt.Fprintf(b, "\t\treturn 0\n")
	fmt.Fprintf(b, "\t}\n\n")
	fmt.Fprintf(b, "\tid := atomic.AddUint32(&ygrpcErrNextID, 1)\n")
	fmt.Fprintf(b, "\tif id == 0 {\n")
	fmt.Fprintf(b, "\t\tid = atomic.AddUint32(&ygrpcErrNextID, 1)\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Lock()\n")
	fmt.Fprintf(
		b,
		"\tygrpcErrMap[id] = ygrpcErrorEntry{msg: append([]byte(nil), msg...), expiresAt: time.Now().Add(3 * time.Second)}\n",
	)
	fmt.Fprintf(b, "\tygrpcErrMu.Unlock()\n")
	fmt.Fprintf(b, "\treturn C.int(id)\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "func ygrpcLookupError(id uint32) ([]byte, bool) {\n")
	fmt.Fprintf(b, "\tif id == 0 {\n\t\treturn nil, false\n\t}\n")
	fmt.Fprintf(b, "\tnow := time.Now()\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Lock()\n")
	fmt.Fprintf(b, "\tentry, ok := ygrpcErrMap[id]\n")
	fmt.Fprintf(b, "\tif ok && now.After(entry.expiresAt) {\n")
	fmt.Fprintf(b, "\t\tdelete(ygrpcErrMap, id)\n")
	fmt.Fprintf(b, "\t\tok = false\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Unlock()\n")
	fmt.Fprintf(b, "\tif !ok {\n\t\treturn nil, false\n\t}\n")
	fmt.Fprintf(b, "\treturn entry.msg, true\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "// Ygrpc_GetErrorMsg returns 0 when found, or 1 when not found/expired.\n")
	fmt.Fprintf(b, "//export Ygrpc_GetErrorMsg\n")
	fmt.Fprintf(
		b,
		"func Ygrpc_GetErrorMsg(errorID C.int, msgPtr *unsafe.Pointer, msgLen *C.int, msgFree *C.FreeFunc) C.int {\n",
	)
	fmt.Fprintf(b, "\tif msgPtr != nil {\n\t\t*msgPtr = nil\n\t}\n")
	fmt.Fprintf(b, "\tif msgLen != nil {\n\t\t*msgLen = 0\n\t}\n")
	fmt.Fprintf(b, "\tif msgFree != nil {\n\t\t*msgFree = nil\n\t}\n")
	fmt.Fprintf(b, "\tif errorID == 0 {\n\t\treturn 1\n\t}\n")
	fmt.Fprintf(b, "\tmsg, ok := ygrpcLookupError(uint32(errorID))\n")
	fmt.Fprintf(b, "\tif !ok {\n\t\treturn 1\n\t}\n")
	fmt.Fprintf(b, "\tif msgLen != nil {\n\t\t*msgLen = C.int(len(msg))\n\t}\n")
	fmt.Fprintf(b, "\tif msgPtr != nil {\n")
	fmt.Fprintf(b, "\t\tbuf := C.CBytes(msg)\n")
	fmt.Fprintf(b, "\t\t*msgPtr = buf\n")
	fmt.Fprintf(b, "\t\tif msgFree != nil {\n\t\t\t*msgFree = C.ygrpc_get_free_func()\n\t\t}\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\treturn 0\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "// main is required when building with -buildmode=c-shared / c-archive.\n")
	fmt.Fprintf(b, "// It is intentionally empty.\n")
	fmt.Fprintf(b, "func main() {}\n")

	return b.String()
}

func buildBinaryUnaryProtoGoFile(
	fd *descriptorpb.FileDescriptorProto,
	msgIndex map[string]*descriptorpb.DescriptorProto,
) string {
	b := &strings.Builder{}

	fmt.Fprintf(b, "// Code generated by protoc-gen-ygrpc-cgo. DO NOT EDIT.\n")
	fmt.Fprintf(b, "// source: %s\n\n", fd.GetName())

	fmt.Fprintf(b, "package main\n\n")

	fmt.Fprintf(b, "/*\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "typedef void (*FreeFunc)(void*);\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_CALL_FREE_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_CALL_FREE_DEFINED\n")
	fmt.Fprintf(b, "static inline void ygrpc_call_free(FreeFunc f, void* p) { if (f != NULL) { f(p); } }\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "*/\n")
	fmt.Fprintf(b, "import \"C\"\n")
	fmt.Fprintf(b, "import \"unsafe\"\n\n")

	for _, svc := range fd.GetService() {
		serviceName := svc.GetName()
		for _, m := range svc.GetMethod() {
			if m.GetClientStreaming() || m.GetServerStreaming() {
				continue
			}

			baseFuncName := serviceName + "_" + m.GetName()
			reqType := strings.TrimPrefix(m.GetInputType(), ".")
			respType := strings.TrimPrefix(m.GetOutputType(), ".")
			reqMsg := reqType
			respMsg := respType
			if dot := strings.LastIndex(reqType, "."); dot != -1 {
				reqMsg = reqType[dot+1:]
			}
			if dot := strings.LastIndex(respType, "."); dot != -1 {
				respMsg = respType[dot+1:]
			}

			reqFreeMode := lookupRequestFreeModeForMethod(fd, m)
			switch reqFreeMode {
			case 2:
				emitBinaryUnaryExport(b, baseFuncName, m.GetName(), reqMsg, reqType, respMsg, respType, false)
				emitBinaryUnaryExport(b, baseFuncName+"_TakeReq", m.GetName(), reqMsg, reqType, respMsg, respType, true)
			case 1:
				emitBinaryUnaryExport(b, baseFuncName+"_TakeReq", m.GetName(), reqMsg, reqType, respMsg, respType, true)
			default:
				emitBinaryUnaryExport(b, baseFuncName, m.GetName(), reqMsg, reqType, respMsg, respType, false)
			}

			reqDesc := msgIndex[reqType]
			respDesc := msgIndex[respType]
			nativeGenMode := lookupNativeGenerationModeForMethod(fd, m)
			if nativeGenMode == 1 {
				// native disabled by method option
			} else if reqDesc != nil && respDesc != nil && isFlatMessage(reqDesc) && isFlatMessage(respDesc) {
				nativeBaseName := baseFuncName + "_Native"
				switch reqFreeMode {
				case 2:
					emitNativeUnaryExport(
						b,
						nativeBaseName,
						m.GetName(),
						reqMsg,
						reqType,
						respMsg,
						respType,
						reqDesc,
						respDesc,
						false,
					)
					emitNativeUnaryExport(
						b,
						nativeBaseName+"_TakeReq",
						m.GetName(),
						reqMsg,
						reqType,
						respMsg,
						respType,
						reqDesc,
						respDesc,
						true,
					)
				case 1:
					emitNativeUnaryExport(
						b,
						nativeBaseName+"_TakeReq",
						m.GetName(),
						reqMsg,
						reqType,
						respMsg,
						respType,
						reqDesc,
						respDesc,
						true,
					)
				default:
					emitNativeUnaryExport(
						b,
						nativeBaseName,
						m.GetName(),
						reqMsg,
						reqType,
						respMsg,
						respType,
						reqDesc,
						respDesc,
						false,
					)
				}
			} else {
				// not eligible for native mode
			}
		}
	}

	return b.String()
}

func emitBinaryUnaryExport(
	b *strings.Builder,
	funcName string,
	rpcName string,
	reqMsg string,
	reqType string,
	respMsg string,
	respType string,
	includeReqFree bool,
) {
	fmt.Fprintf(b, "// %s is the Binary Mode (protobuf bytes) entrypoint for:\n", funcName)
	fmt.Fprintf(b, "//   rpc %s(%s) returns (%s);\n", rpcName, reqType, respType)
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// ABI (no C structs):\n")
	fmt.Fprintf(b, "//   - Response bytes are returned as a (ptr, len, free) triple.\n")
	if includeReqFree {
		fmt.Fprintf(b, "//   - Request bytes are passed as a (ptr, len, free) triple.\n")
	} else {
		fmt.Fprintf(b, "//   - Request bytes are passed as a (ptr, len) pair (default).\n")
	}
	fmt.Fprintf(b, "//   - %sPtr/%sLen contains serialized %s protobuf bytes.\n", reqMsg, reqMsg, reqType)
	fmt.Fprintf(
		b,
		"//   - %sPtr/%sLen/%sFree must be set to serialized %s protobuf bytes (output params).\n",
		respMsg,
		respMsg,
		respMsg,
		respType,
	)
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// Return:\n")
	fmt.Fprintf(b, "//   - 0 on success; non-zero is an errorId.\n")
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// Error reporting:\n")
	fmt.Fprintf(b, "//   - Use Ygrpc_GetErrorMsg(errorId, ...) within 3s to fetch the message.\n")

	fmt.Fprintf(b, "//export %s\n", funcName)
	if includeReqFree {
		fmt.Fprintf(
			b,
			"func %s(inPtr unsafe.Pointer, inLen C.int, inFree C.FreeFunc, outPtr *unsafe.Pointer, outLen *C.int, outFree *C.FreeFunc) C.int {\n",
			funcName,
		)
		fmt.Fprintf(b, "\t_ = inLen\n")
		fmt.Fprintf(b, "\tif inPtr != nil && inFree != nil {\n")
		fmt.Fprintf(b, "\t\tC.ygrpc_call_free(inFree, inPtr)\n")
		fmt.Fprintf(b, "\t}\n")
	} else {
		fmt.Fprintf(
			b,
			"func %s(inPtr unsafe.Pointer, inLen C.int, outPtr *unsafe.Pointer, outLen *C.int, outFree *C.FreeFunc) C.int {\n",
			funcName,
		)
		fmt.Fprintf(b, "\t_ = inPtr\n")
		fmt.Fprintf(b, "\t_ = inLen\n")
	}

	fmt.Fprintf(b, "\tif outPtr != nil {\n\t\t*outPtr = nil\n\t}\n")
	fmt.Fprintf(b, "\tif outLen != nil {\n\t\t*outLen = 0\n\t}\n")
	fmt.Fprintf(b, "\tif outFree != nil {\n\t\t*outFree = nil\n\t} else {\n\t\t// ok\n\t}\n")

	fmt.Fprintf(b, "\treturn 0\n")
	fmt.Fprintf(b, "}\n\n")
}

func emitNativeUnaryExport(
	b *strings.Builder,
	funcName string,
	rpcName string,
	reqMsg string,
	reqType string,
	respMsg string,
	respType string,
	reqDesc *descriptorpb.DescriptorProto,
	respDesc *descriptorpb.DescriptorProto,
	includeReqFree bool,
) {
	fmt.Fprintf(b, "// %s is the Native Mode (flat message fields) entrypoint for:\n", funcName)
	fmt.Fprintf(b, "//   rpc %s(%s) returns (%s);\n", rpcName, reqType, respType)
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// ABI (no C structs):\n")
	fmt.Fprintf(b, "//   - Flat request/response fields are expanded into parameters.\n")
	if includeReqFree {
		fmt.Fprintf(b, "//   - Request string/bytes fields are passed as (ptr, len, free).\n")
	} else {
		fmt.Fprintf(b, "//   - Request string/bytes fields are passed as (ptr, len) (default).\n")
	}
	fmt.Fprintf(b, "//   - Response string/bytes fields are returned as (ptr, len, free) triples (output params).\n")
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// Return:\n")
	fmt.Fprintf(b, "//   - 0 on success; non-zero is an errorId.\n")
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// Error reporting:\n")
	fmt.Fprintf(b, "//   - Use Ygrpc_GetErrorMsg(errorId, ...) within 3s to fetch the message.\n")

	params := buildNativeUnaryParams(reqMsg, reqDesc, respMsg, respDesc, includeReqFree)
	fmt.Fprintf(b, "//export %s\n", funcName)
	fmt.Fprintf(b, "func %s(%s) C.int {\n", funcName, params)

	if includeReqFree {
		for _, f := range reqDesc.GetField() {
			if isNativeStringOrBytes(f.GetType()) {
				inBase := "in" + goIdentFromProtoName(f.GetName())
				fmt.Fprintf(b, "\tif %sPtr != nil && %sFree != nil {\n", inBase, inBase)
				fmt.Fprintf(b, "\t\tC.ygrpc_call_free(%sFree, %sPtr)\n", inBase, inBase)
				fmt.Fprintf(b, "\t} else {\n\t\t// ok\n\t}\n")
			} else {
				// ok
			}
		}
	} else {
		// ok
	}

	for _, f := range respDesc.GetField() {
		outBase := "out" + goIdentFromProtoName(f.GetName())
		if isNativeStringOrBytes(f.GetType()) {
			fmt.Fprintf(b, "\tif %sPtr != nil {\n\t\t*%sPtr = nil\n\t} else {\n\t\t// ok\n\t}\n", outBase, outBase)
			fmt.Fprintf(b, "\tif %sLen != nil {\n\t\t*%sLen = 0\n\t} else {\n\t\t// ok\n\t}\n", outBase, outBase)
			fmt.Fprintf(b, "\tif %sFree != nil {\n\t\t*%sFree = nil\n\t} else {\n\t\t// ok\n\t}\n", outBase, outBase)
		} else {
			fmt.Fprintf(b, "\tif %s != nil {\n\t\t*%s = 0\n\t} else {\n\t\t// ok\n\t}\n", outBase, outBase)
		}
	}

	fmt.Fprintf(b, "\treturn 0\n")
	fmt.Fprintf(b, "}\n\n")
}

func buildNativeUnaryParams(
	reqMsg string,
	reqDesc *descriptorpb.DescriptorProto,
	respMsg string,
	respDesc *descriptorpb.DescriptorProto,
	includeReqFree bool,
) string {
	params := make([]string, 0)

	for _, f := range reqDesc.GetField() {
		inBase := "in" + goIdentFromProtoName(f.GetName())
		if isNativeStringOrBytes(f.GetType()) {
			params = append(params, inBase+"Ptr unsafe.Pointer")
			params = append(params, inBase+"Len C.int")
			if includeReqFree {
				params = append(params, inBase+"Free C.FreeFunc")
			} else {
				// ok
			}
		} else {
			t, ok := nativeScalarCType(f.GetType())
			if ok {
				params = append(params, inBase+" "+t)
			} else {
				params = append(params, inBase+" C.int")
			}
		}
	}

	for _, f := range respDesc.GetField() {
		outBase := "out" + goIdentFromProtoName(f.GetName())
		if isNativeStringOrBytes(f.GetType()) {
			params = append(params, outBase+"Ptr *unsafe.Pointer")
			params = append(params, outBase+"Len *C.int")
			params = append(params, outBase+"Free *C.FreeFunc")
		} else {
			t, ok := nativeScalarCType(f.GetType())
			if ok {
				params = append(params, outBase+" *"+t)
			} else {
				params = append(params, outBase+" *C.int")
			}
		}
	}

	return strings.Join(params, ", ")
}

const ygrpcCgoNativeGenOptionFieldNumber protowire.Number = 50002

// lookupNativeGenerationModeForMethod reads the FileOptions/MethodOptions extension (unknown field) for:
//
//	extend google.protobuf.FileOptions   { int32 ygrpc_cgo_native = 50002; }
//	extend google.protobuf.MethodOptions { int32 ygrpc_cgo_native = 50002; }
//
// Precedence:
//   - MethodOptions overrides FileOptions.
//
// Semantics:
//   - 0 (default): generate native functions when eligible
//   - 1: do not generate native functions
func lookupNativeGenerationModeForMethod(
	fd *descriptorpb.FileDescriptorProto,
	m *descriptorpb.MethodDescriptorProto,
) int32 {
	if m != nil {
		mode, ok := readNativeGenModeFromMethodOptions(m.GetOptions())
		if ok && (mode == 0 || mode == 1) {
			return mode
		}
	}
	if fd != nil {
		mode, ok := readNativeGenModeFromFileOptions(fd.GetOptions())
		if ok && (mode == 0 || mode == 1) {
			return mode
		}
	}
	return 0
}

func readNativeGenModeFromMethodOptions(opts *descriptorpb.MethodOptions) (int32, bool) {
	if opts == nil {
		return 0, false
	}
	unknown := opts.ProtoReflect().GetUnknown()
	if len(unknown) == 0 {
		return 0, false
	}
	val, ok := consumeUnknownVarintField(unknown, ygrpcCgoNativeGenOptionFieldNumber)
	if !ok {
		return 0, false
	}
	return int32(val), true
}

func readNativeGenModeFromFileOptions(opts *descriptorpb.FileOptions) (int32, bool) {
	if opts == nil {
		return 0, false
	}
	unknown := opts.ProtoReflect().GetUnknown()
	if len(unknown) == 0 {
		return 0, false
	}
	val, ok := consumeUnknownVarintField(unknown, ygrpcCgoNativeGenOptionFieldNumber)
	if !ok {
		return 0, false
	}
	return int32(val), true
}

func goIdentFromProtoName(name string) string {
	parts := strings.Split(name, "_")
	b := &strings.Builder{}
	for _, p := range parts {
		if p == "" {
			continue
		} else {
			// ok
		}
		if len(p) == 1 {
			b.WriteString(strings.ToUpper(p))
		} else {
			b.WriteString(strings.ToUpper(p[:1]))
			b.WriteString(p[1:])
		}
	}
	return b.String()
}

func isNativeStringOrBytes(t descriptorpb.FieldDescriptorProto_Type) bool {
	switch t {
	case descriptorpb.FieldDescriptorProto_TYPE_STRING, descriptorpb.FieldDescriptorProto_TYPE_BYTES:
		return true
	default:
		return false
	}
}

func nativeScalarCType(t descriptorpb.FieldDescriptorProto_Type) (string, bool) {
	switch t {
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL:
		return "C.int", true
	case descriptorpb.FieldDescriptorProto_TYPE_FLOAT:
		return "C.float", true
	case descriptorpb.FieldDescriptorProto_TYPE_DOUBLE:
		return "C.double", true
	case descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32:
		return "C.int", true
	case descriptorpb.FieldDescriptorProto_TYPE_UINT32:
		return "C.uint", true
	case descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64:
		return "C.longlong", true
	case descriptorpb.FieldDescriptorProto_TYPE_UINT64:
		return "C.ulonglong", true
	default:
		return "", false
	}
}

// isFlatMessage returns true when msg contains only scalar (non-enum) fields and
// does not use optional/repeated/oneof/map/nested message.
//
// This is the eligibility predicate for generating Native Mode entrypoints.
func isFlatMessage(msg *descriptorpb.DescriptorProto) bool {
	for _, f := range msg.GetField() {
		if isFlatField(f) {
			continue
		} else {
			return false
		}
	}
	return true
}

func isFlatField(f *descriptorpb.FieldDescriptorProto) bool {
	if f.GetProto3Optional() {
		return false
	} else {
		// ok
	}

	if f.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
		return false
	} else {
		// ok
	}

	if f.OneofIndex != nil {
		return false
	} else {
		// ok
	}

	switch f.GetType() {
	case descriptorpb.FieldDescriptorProto_TYPE_BOOL,
		descriptorpb.FieldDescriptorProto_TYPE_STRING,
		descriptorpb.FieldDescriptorProto_TYPE_BYTES,
		descriptorpb.FieldDescriptorProto_TYPE_DOUBLE,
		descriptorpb.FieldDescriptorProto_TYPE_FLOAT,
		descriptorpb.FieldDescriptorProto_TYPE_INT32,
		descriptorpb.FieldDescriptorProto_TYPE_INT64,
		descriptorpb.FieldDescriptorProto_TYPE_UINT32,
		descriptorpb.FieldDescriptorProto_TYPE_UINT64,
		descriptorpb.FieldDescriptorProto_TYPE_SINT32,
		descriptorpb.FieldDescriptorProto_TYPE_SINT64,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_FIXED64,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED32,
		descriptorpb.FieldDescriptorProto_TYPE_SFIXED64:
		return true
	case descriptorpb.FieldDescriptorProto_TYPE_ENUM,
		descriptorpb.FieldDescriptorProto_TYPE_MESSAGE,
		descriptorpb.FieldDescriptorProto_TYPE_GROUP:
		return false
	default:
		return false
	}
}

const ygrpcCgoReqFreeOptionFieldNumber protowire.Number = 50001

func lookupRequestFreeModeForMethod(fd *descriptorpb.FileDescriptorProto, m *descriptorpb.MethodDescriptorProto) int32 {
	if m != nil {
		mode, ok := readReqFreeModeFromMethodOptions(m.GetOptions())
		if ok {
			if mode == 0 || mode == 1 || mode == 2 {
				return mode
			}
			return 0
		}
	}
	if fd != nil {
		mode, ok := readReqFreeModeFromFileOptions(fd.GetOptions())
		if ok {
			if mode == 0 || mode == 1 || mode == 2 {
				return mode
			}
			return 0
		}
	}
	return 0
}

func buildMessageIndex(files []*descriptorpb.FileDescriptorProto) map[string]*descriptorpb.DescriptorProto {
	idx := map[string]*descriptorpb.DescriptorProto{}
	for _, fd := range files {
		pkg := fd.GetPackage()
		for _, m := range fd.GetMessageType() {
			indexMessage(idx, pkg, m)
		}
	}
	return idx
}

func indexMessage(idx map[string]*descriptorpb.DescriptorProto, prefix string, m *descriptorpb.DescriptorProto) {
	full := m.GetName()
	if prefix != "" {
		full = prefix + "." + m.GetName()
	}
	idx[full] = m
	for _, nested := range m.GetNestedType() {
		indexMessage(idx, full, nested)
	}
}

func readReqFreeModeFromMethodOptions(opts *descriptorpb.MethodOptions) (int32, bool) {
	if opts == nil {
		return 0, false
	}
	unknown := opts.ProtoReflect().GetUnknown()
	if len(unknown) == 0 {
		return 0, false
	}
	val, ok := consumeUnknownVarintField(unknown, ygrpcCgoReqFreeOptionFieldNumber)
	if !ok {
		return 0, false
	}
	return int32(val), true
}

func readReqFreeModeFromFileOptions(opts *descriptorpb.FileOptions) (int32, bool) {
	if opts == nil {
		return 0, false
	}
	unknown := opts.ProtoReflect().GetUnknown()
	if len(unknown) == 0 {
		return 0, false
	}
	val, ok := consumeUnknownVarintField(unknown, ygrpcCgoReqFreeOptionFieldNumber)
	if !ok {
		return 0, false
	}
	return int32(val), true
}

func consumeUnknownVarintField(unknown []byte, fieldNumber protowire.Number) (uint64, bool) {
	for len(unknown) > 0 {
		num, typ, n := protowire.ConsumeTag(unknown)
		if n < 0 {
			return 0, false
		}
		unknown = unknown[n:]

		var (
			v uint64
		)
		switch typ {
		case protowire.VarintType:
			vv, nn := protowire.ConsumeVarint(unknown)
			if nn < 0 {
				return 0, false
			}
			v = vv
			n = nn
		case protowire.Fixed32Type:
			_, nn := protowire.ConsumeFixed32(unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		case protowire.Fixed64Type:
			_, nn := protowire.ConsumeFixed64(unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		case protowire.BytesType:
			_, nn := protowire.ConsumeBytes(unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		case protowire.StartGroupType:
			_, nn := protowire.ConsumeGroup(num, unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		default:
			return 0, false
		}

		if num == fieldNumber && typ == protowire.VarintType {
			return v, true
		}
		unknown = unknown[n:]
	}
	return 0, false
}
