package main

import (
	"fmt"
	"log"
	"os"
	"slices"
	"strings"

	"github.com/ygrpc/protocgen/protocplugin"
	"google.golang.org/protobuf/encoding/protowire"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	logPrefix := "protoc-gen-ygrpc-cgo: "
	log.SetPrefix(logPrefix)

	_, _, err := protocplugin.ProtoGeneratorMain(protocCgoHandler, os.Stdin, os.Stdout, logPrefix)
	if err != nil {
		log.Fatalf("error: failed to execute protoc plugin handler: %v", err)
	}
}

func protocCgoHandler(request *pluginpb.CodeGeneratorRequest) (genFiles []*pluginpb.CodeGeneratorResponse_File) {
	msgIndex := buildMessageIndex(request.GetProtoFile())

	filesToGenerate := make([]*descriptorpb.FileDescriptorProto, 0)
	for _, fd := range request.GetProtoFile() {
		if !slices.Contains(request.FileToGenerate, fd.GetName()) {
			continue
		}
		filesToGenerate = append(filesToGenerate, fd)
	}

	if len(filesToGenerate) == 0 {
		return nil
	}

	// Emit runtime once per invocation, separate from per-proto entrypoints.
	runtimeOutName := "ygrpc_cgo/ygrpc_runtime.go"
	genFiles = append(genFiles, &pluginpb.CodeGeneratorResponse_File{
		Name:    proto.String(runtimeOutName),
		Content: proto.String(buildBinaryUnaryRuntimeGoFile()),
	})

	for _, fd := range filesToGenerate {
		originalFile := fd.GetName()
		originalFilenameOnly := protocplugin.ExtractFilename(originalFile)
		goOutName := "ygrpc_cgo/" + originalFilenameOnly + ".ygrpc.cgo.go"

		goContent := buildBinaryUnaryProtoGoFile(fd, msgIndex)
		genFiles = append(genFiles, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(goOutName),
			Content: proto.String(goContent),
		})
	}

	return genFiles
}

func buildBinaryUnaryRuntimeGoFile() string {
	b := &strings.Builder{}

	fmt.Fprintf(b, "// Code generated by protoc-gen-ygrpc-cgo. DO NOT EDIT.\n")
	fmt.Fprintf(b, "// source: ygrpc_runtime\n\n")

	fmt.Fprintf(b, "package main\n\n")

	fmt.Fprintf(b, "/*\n")
	fmt.Fprintf(b, "#include <stdlib.h>\n\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "typedef void (*FreeFunc)(void*);\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "static FreeFunc ygrpc_get_free_func(void) { return free; }\n")
	fmt.Fprintf(b, "*/\n")
	fmt.Fprintf(b, "import \"C\"\n")

	fmt.Fprintf(b, "import (\n")
	fmt.Fprintf(b, "\t\"sync\"\n")
	fmt.Fprintf(b, "\t\"sync/atomic\"\n")
	fmt.Fprintf(b, "\t\"time\"\n")
	fmt.Fprintf(b, "\t\"unsafe\"\n")
	fmt.Fprintf(b, ")\n\n")

	fmt.Fprintf(b, "type ygrpcErrorEntry struct {\n")
	fmt.Fprintf(b, "\tmsg []byte\n")
	fmt.Fprintf(b, "\texpiresAt time.Time\n")
	fmt.Fprintf(b, "}\n\n")
	fmt.Fprintf(b, "var (\n")
	fmt.Fprintf(b, "\tygrpcErrMu sync.Mutex\n")
	fmt.Fprintf(b, "\tygrpcErrNextID uint32\n")
	fmt.Fprintf(b, "\tygrpcErrMap = map[uint32]ygrpcErrorEntry{}\n")
	fmt.Fprintf(b, ")\n\n")

	fmt.Fprintf(b, "func ygrpcStoreError(msg []byte) C.int {\n")
	fmt.Fprintf(b, "\tif len(msg) == 0 {\n")
	fmt.Fprintf(b, "\t\treturn 0\n")
	fmt.Fprintf(b, "\t}\n\n")
	fmt.Fprintf(b, "\tid := atomic.AddUint32(&ygrpcErrNextID, 1)\n")
	fmt.Fprintf(b, "\tif id == 0 {\n")
	fmt.Fprintf(b, "\t\tid = atomic.AddUint32(&ygrpcErrNextID, 1)\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Lock()\n")
	fmt.Fprintf(
		b,
		"\tygrpcErrMap[id] = ygrpcErrorEntry{msg: append([]byte(nil), msg...), expiresAt: time.Now().Add(3 * time.Second)}\n",
	)
	fmt.Fprintf(b, "\tygrpcErrMu.Unlock()\n")
	fmt.Fprintf(b, "\treturn C.int(id)\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "func ygrpcLookupError(id uint32) ([]byte, bool) {\n")
	fmt.Fprintf(b, "\tif id == 0 {\n\t\treturn nil, false\n\t}\n")
	fmt.Fprintf(b, "\tnow := time.Now()\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Lock()\n")
	fmt.Fprintf(b, "\tentry, ok := ygrpcErrMap[id]\n")
	fmt.Fprintf(b, "\tif ok && now.After(entry.expiresAt) {\n")
	fmt.Fprintf(b, "\t\tdelete(ygrpcErrMap, id)\n")
	fmt.Fprintf(b, "\t\tok = false\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\tygrpcErrMu.Unlock()\n")
	fmt.Fprintf(b, "\tif !ok {\n\t\treturn nil, false\n\t}\n")
	fmt.Fprintf(b, "\treturn entry.msg, true\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "// Ygrpc_GetErrorMsg returns 0 when found, or 1 when not found/expired.\n")
	fmt.Fprintf(b, "//export Ygrpc_GetErrorMsg\n")
	fmt.Fprintf(
		b,
		"func Ygrpc_GetErrorMsg(errorID C.int, msgPtr *unsafe.Pointer, msgLen *C.int, msgFree *C.FreeFunc) C.int {\n",
	)
	fmt.Fprintf(b, "\tif msgPtr != nil {\n\t\t*msgPtr = nil\n\t}\n")
	fmt.Fprintf(b, "\tif msgLen != nil {\n\t\t*msgLen = 0\n\t}\n")
	fmt.Fprintf(b, "\tif msgFree != nil {\n\t\t*msgFree = nil\n\t}\n")
	fmt.Fprintf(b, "\tif errorID == 0 {\n\t\treturn 1\n\t}\n")
	fmt.Fprintf(b, "\tmsg, ok := ygrpcLookupError(uint32(errorID))\n")
	fmt.Fprintf(b, "\tif !ok {\n\t\treturn 1\n\t}\n")
	fmt.Fprintf(b, "\tif msgLen != nil {\n\t\t*msgLen = C.int(len(msg))\n\t}\n")
	fmt.Fprintf(b, "\tif msgPtr != nil {\n")
	fmt.Fprintf(b, "\t\tbuf := C.CBytes(msg)\n")
	fmt.Fprintf(b, "\t\t*msgPtr = buf\n")
	fmt.Fprintf(b, "\t\tif msgFree != nil {\n\t\t\t*msgFree = C.ygrpc_get_free_func()\n\t\t}\n")
	fmt.Fprintf(b, "\t}\n")
	fmt.Fprintf(b, "\treturn 0\n")
	fmt.Fprintf(b, "}\n\n")

	fmt.Fprintf(b, "// main is required when building with -buildmode=c-shared / c-archive.\n")
	fmt.Fprintf(b, "// It is intentionally empty.\n")
	fmt.Fprintf(b, "func main() {}\n")

	return b.String()
}

func buildBinaryUnaryProtoGoFile(fd *descriptorpb.FileDescriptorProto, msgIndex map[string]*descriptorpb.DescriptorProto) string {
	b := &strings.Builder{}

	fmt.Fprintf(b, "// Code generated by protoc-gen-ygrpc-cgo. DO NOT EDIT.\n")
	fmt.Fprintf(b, "// source: %s\n\n", fd.GetName())

	fmt.Fprintf(b, "package main\n\n")

	fmt.Fprintf(b, "/*\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_FREEFUNC_DEFINED\n")
	fmt.Fprintf(b, "typedef void (*FreeFunc)(void*);\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "#ifndef YGRPC_CGO_CALL_FREE_DEFINED\n")
	fmt.Fprintf(b, "#define YGRPC_CGO_CALL_FREE_DEFINED\n")
	fmt.Fprintf(b, "static inline void ygrpc_call_free(FreeFunc f, void* p) { if (f != NULL) { f(p); } }\n")
	fmt.Fprintf(b, "#endif\n")
	fmt.Fprintf(b, "*/\n")
	fmt.Fprintf(b, "import \"C\"\n")
	fmt.Fprintf(b, "import \"unsafe\"\n\n")

	for _, svc := range fd.GetService() {
		serviceName := svc.GetName()
		for _, m := range svc.GetMethod() {
			if m.GetClientStreaming() || m.GetServerStreaming() {
				continue
			}

			baseFuncName := serviceName + "_" + m.GetName()
			reqType := strings.TrimPrefix(m.GetInputType(), ".")
			respType := strings.TrimPrefix(m.GetOutputType(), ".")
			reqMsg := reqType
			respMsg := respType
			if dot := strings.LastIndex(reqType, "."); dot != -1 {
				reqMsg = reqType[dot+1:]
			}
			if dot := strings.LastIndex(respType, "."); dot != -1 {
				respMsg = respType[dot+1:]
			}

			reqFreeMode := lookupRequestFreeMode(reqType, msgIndex)
			if reqFreeMode == 2 {
				emitBinaryUnaryExport(b, baseFuncName, m.GetName(), reqMsg, reqType, respMsg, respType, false)
				emitBinaryUnaryExport(b, baseFuncName+"_TakeReq", m.GetName(), reqMsg, reqType, respMsg, respType, true)
			} else if reqFreeMode == 1 {
				emitBinaryUnaryExport(b, baseFuncName+"_TakeReq", m.GetName(), reqMsg, reqType, respMsg, respType, true)
			} else {
				emitBinaryUnaryExport(b, baseFuncName, m.GetName(), reqMsg, reqType, respMsg, respType, false)
			}
		}
	}

	return b.String()
}

func emitBinaryUnaryExport(
	b *strings.Builder,
	funcName string,
	rpcName string,
	reqMsg string,
	reqType string,
	respMsg string,
	respType string,
	includeReqFree bool,
) {
	fmt.Fprintf(b, "// %s is the Binary Mode (protobuf bytes) entrypoint for:\n", funcName)
	fmt.Fprintf(b, "//   rpc %s(%s) returns (%s);\n", rpcName, reqType, respType)
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// ABI (no C structs):\n")
	fmt.Fprintf(b, "//   - Response bytes are returned as a (ptr, len, free) triple.\n")
	if includeReqFree {
		fmt.Fprintf(b, "//   - Request bytes are passed as a (ptr, len, free) triple.\n")
	} else {
		fmt.Fprintf(b, "//   - Request bytes are passed as a (ptr, len) pair (default).\n")
	}
	fmt.Fprintf(b, "//   - %sPtr/%sLen contains serialized %s protobuf bytes.\n", reqMsg, reqMsg, reqType)
	fmt.Fprintf(b, "//   - %sPtr/%sLen/%sFree must be set to serialized %s protobuf bytes (output params).\n", respMsg, respMsg, respMsg, respType)
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// Return:\n")
	fmt.Fprintf(b, "//   - 0 on success; non-zero is an errorId.\n")
	fmt.Fprintf(b, "//\n")
	fmt.Fprintf(b, "// Error reporting:\n")
	fmt.Fprintf(b, "//   - Use Ygrpc_GetErrorMsg(errorId, ...) within 3s to fetch the message.\n")

	fmt.Fprintf(b, "//export %s\n", funcName)
	if includeReqFree {
		fmt.Fprintf(
			b,
			"func %s(%sPtr unsafe.Pointer, %sLen C.int, %sFree C.FreeFunc, %sPtr *unsafe.Pointer, %sLen *C.int, %sFree *C.FreeFunc) C.int {\n",
			funcName,
			reqMsg,
			reqMsg,
			reqMsg,
			respMsg,
			respMsg,
			respMsg,
		)
		fmt.Fprintf(b, "\t_ = %sLen\n", reqMsg)
		fmt.Fprintf(b, "\tif %sPtr != nil && %sFree != nil {\n", reqMsg, reqMsg)
		fmt.Fprintf(b, "\t\tC.ygrpc_call_free(%sFree, %sPtr)\n", reqMsg, reqMsg)
		fmt.Fprintf(b, "\t}\n")
	} else {
		fmt.Fprintf(
			b,
			"func %s(%sPtr unsafe.Pointer, %sLen C.int, %sPtr *unsafe.Pointer, %sLen *C.int, %sFree *C.FreeFunc) C.int {\n",
			funcName,
			reqMsg,
			reqMsg,
			respMsg,
			respMsg,
			respMsg,
		)
		fmt.Fprintf(b, "\t_ = %sPtr\n", reqMsg)
		fmt.Fprintf(b, "\t_ = %sLen\n", reqMsg)
	}

	fmt.Fprintf(b, "\tif %sPtr != nil {\n\t\t*%sPtr = nil\n\t}\n", respMsg, respMsg)
	fmt.Fprintf(b, "\tif %sLen != nil {\n\t\t*%sLen = 0\n\t}\n", respMsg, respMsg)
	if includeReqFree {
		fmt.Fprintf(b, "\tif %sFree != nil {\n\t\t*%sFree = nil\n\t}\n", respMsg, respMsg)
	} else {
		fmt.Fprintf(b, "\tif %sFree != nil {\n\t\t*%sFree = nil\n\t}\n", respMsg, respMsg)
	}

	fmt.Fprintf(b, "\treturn 0\n")
	fmt.Fprintf(b, "}\n\n")
}

const ygrpcCgoReqFreeOptionFieldNumber protowire.Number = 50001

func buildMessageIndex(files []*descriptorpb.FileDescriptorProto) map[string]*descriptorpb.DescriptorProto {
	idx := map[string]*descriptorpb.DescriptorProto{}
	for _, fd := range files {
		pkg := fd.GetPackage()
		for _, m := range fd.GetMessageType() {
			indexMessage(idx, pkg, m)
		}
	}
	return idx
}

func indexMessage(idx map[string]*descriptorpb.DescriptorProto, prefix string, m *descriptorpb.DescriptorProto) {
	full := m.GetName()
	if prefix != "" {
		full = prefix + "." + m.GetName()
	}
	idx[full] = m
	for _, nested := range m.GetNestedType() {
		indexMessage(idx, full, nested)
	}
}

func lookupRequestFreeMode(fullMessageType string, msgIndex map[string]*descriptorpb.DescriptorProto) int32 {
	msg := msgIndex[fullMessageType]
	if msg == nil {
		return 0
	}
	mode, ok := readReqFreeModeFromMessageOptions(msg.GetOptions())
	if !ok {
		return 0
	}
	if mode == 0 || mode == 1 || mode == 2 {
		return mode
	}
	return 0
}

func readReqFreeModeFromMessageOptions(opts *descriptorpb.MessageOptions) (int32, bool) {
	if opts == nil {
		return 0, false
	}
	unknown := opts.ProtoReflect().GetUnknown()
	if len(unknown) == 0 {
		return 0, false
	}
	val, ok := consumeUnknownVarintField(unknown, ygrpcCgoReqFreeOptionFieldNumber)
	if !ok {
		return 0, false
	}
	return int32(val), true
}

func consumeUnknownVarintField(unknown []byte, fieldNumber protowire.Number) (uint64, bool) {
	for len(unknown) > 0 {
		num, typ, n := protowire.ConsumeTag(unknown)
		if n < 0 {
			return 0, false
		}
		unknown = unknown[n:]

		var (
			v uint64
		)
		switch typ {
		case protowire.VarintType:
			vv, nn := protowire.ConsumeVarint(unknown)
			if nn < 0 {
				return 0, false
			}
			v = vv
			n = nn
		case protowire.Fixed32Type:
			_, nn := protowire.ConsumeFixed32(unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		case protowire.Fixed64Type:
			_, nn := protowire.ConsumeFixed64(unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		case protowire.BytesType:
			_, nn := protowire.ConsumeBytes(unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		case protowire.StartGroupType:
			_, nn := protowire.ConsumeGroup(num, unknown)
			if nn < 0 {
				return 0, false
			}
			n = nn
		default:
			return 0, false
		}

		if num == fieldNumber && typ == protowire.VarintType {
			return v, true
		}
		unknown = unknown[n:]
	}
	return 0, false
}
