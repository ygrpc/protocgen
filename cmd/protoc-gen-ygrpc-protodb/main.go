package main

import (
	"bytes"
	"fmt"
	"github.com/ygrpc/protocgen/protocplugin"
	"github.com/ygrpc/protodb"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
	"log"
	"os"
	"slices"
	"strconv"
	"strings"
	"text/template"
)

func main() {
	logPrefix := "protoc-gen-ygrpc-protodb: "

	log.SetPrefix(logPrefix)

	var protocgenPort int

	//search protocgen-port from os.Args
	for i := 0; i < len(os.Args); i++ {
		//log.Println("os.Args[", i, "]=", os.Args[i])
		if strings.HasPrefix(os.Args[i], "--protocgen-port") {
			eqPos := strings.Index(os.Args[i], "=")
			if eqPos == -1 {
				log.Println("protocgen-port is not parse ok, use default port:", protocplugin.DefaultProtogenPort)
				protocgenPort = protocplugin.DefaultProtogenPort
				break
			}
			protocgenPort, _ = strconv.Atoi(os.Args[i][eqPos+1:])
			if protocgenPort <= 0 {
				log.Println("protocgen-port is not parse ok, use default port:", protocplugin.DefaultProtogenPort)
				protocgenPort = protocplugin.DefaultProtogenPort
			}
			break
		}
	}

	if protocgenPort != 0 {
		log.Println("protocgen-port:", protocgenPort)

		server := &protocplugin.TProtocgenRpc{
			Port:    protocgenPort,
			Handler: protocProtodbHandler,
		}

		server.Run()
	} else {
		//time.Sleep(20 * time.Second)
		_, _, err := protocplugin.ProtoGeneratorMain(protocProtodbHandler, os.Stdin, os.Stdout, logPrefix)
		if err != nil {
			log.Fatalf("error: failed to execute protoc plugin handler: %v", err)
		}
	}

}

func protocProtodbHandler(request *pluginpb.CodeGeneratorRequest) (genFiles []*pluginpb.CodeGeneratorResponse_File) {
	msgListProtoFileHead := `//generated by ygrpc-protodb. DO NOT EDIT.
//source: {{.original_file}}

package {{.go_sub_package}}

import "google.golang.org/protobuf/proto"
import "github.com/ygrpc/protodb/msgstore"
`

	var fd *descriptorpb.FileDescriptorProto

	oneGetMsg := `
var msg{{.Msg}} *{{.Msg}}
func get{{.Msg}}(new bool) proto.Message {
	if new {
		return &{{.Msg}}{}
	}
	if msg{{.Msg}} == nil {
		msg{{.Msg}} = &{{.Msg}}{}
	}

	return msg{{.Msg}}
}

const {{.Msg}}LastFieldNo = {{.MsgLastFieldNo}}

func (x *{{.Msg}}) LastFieldNo() int32 {
	return {{.Msg}}LastFieldNo
}
{{.FieldProtoMsg}}
`

	for _, fd = range request.GetProtoFile() {
		if !slices.Contains(request.FileToGenerate, fd.GetName()) {
			//not generate this file
			continue
		}
		needWriteThisFile := false

		original_file := fd.GetName()
		originalFilenameOnly := protocplugin.ExtractFilename(original_file)
		rpcFilePath := fd.GetOptions().GetGoPackage() + "/" + originalFilenameOnly + ".protodb.go"
		//rpcFilename := originalFilenameOnly + ".protodb.go"

		tHead := template.Must(template.New("proto_head").Parse(msgListProtoFileHead))
		sqlHeadData := map[string]interface{}{
			"original_file":     original_file,
			"original_filename": originalFilenameOnly,
			"package":           fd.GetPackage(),
			"optimize_for":      "",
			"go_package":        fd.GetOptions().GetGoPackage(),
			"go_sub_package":    getGoSubPackage(fd.GetOptions().GetGoPackage(), fd.GetPackage()),
			"java_package":      fd.GetOptions().GetJavaPackage(),
		}
		if fd.GetOptions().OptimizeFor != nil {
			sqlHeadData["optimize_for"] = fd.GetOptions().GetOptimizeFor().String()
		}

		var tplBytes bytes.Buffer
		if err := tHead.Execute(&tplBytes, sqlHeadData); err != nil {
			log.Fatal(err)
		}

		protoFileContent := tplBytes.String()

		tMsg := template.Must(template.New("rpc_msg").Parse(oneGetMsg))

		allMsgs := make([]string, 0)

		//process every msg
		for _, msg := range fd.MessageType {
			msgName := msg.GetName()

			needMsgList := false
			FieldProtoMsgFields := []*descriptorpb.FieldDescriptorProto{}

			if strings.HasPrefix(msgName, "Db") ||
				strings.HasPrefix(msgName, "DB") {
				needMsgList = true
			}

			if proto.HasExtension(msg.Options, protodb.E_Pdbm) {
				//get extension protodb.Pdbm
				pdbmInf := proto.GetExtension(msg.Options, protodb.E_Pdbm)
				pdbm := pdbmInf.(*protodb.PDBMsg)
				if pdbm != nil {
					if pdbm.MsgList == 4 {
						//no need msg list
						needMsgList = false
						continue
					}
					if pdbm.NotDB {
						//not generate db table
						needMsgList = false
						continue
					}
				}
			}

			if !needMsgList {
				continue
			}
			var msgLastFieldNo int32 = 0
			//iterate all fields
			for _, field := range msg.GetField() {
				if field.GetNumber() > msgLastFieldNo {
					msgLastFieldNo = field.GetNumber()
				}

				if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
					FieldProtoMsgFields = append(FieldProtoMsgFields, field)
				}
			}

			FieldProtoMsgStr := genFieldProtoMsg(msg, FieldProtoMsgFields)

			tMsgData := map[string]interface{}{
				"Msg":            msgName,
				"MsgLastFieldNo": msgLastFieldNo,
				"FieldProtoMsg":  FieldProtoMsgStr,
			}

			allMsgs = append(allMsgs, msgName)

			needWriteThisFile = true

			var msgBytes bytes.Buffer
			if err := tMsg.Execute(&msgBytes, tMsgData); err != nil {
				log.Fatal(err)
			}

			protoFileContent = protoFileContent + msgBytes.String()
		}

		if !needWriteThisFile {
			continue
		}

		//generate init func
		initStrBilder := strings.Builder{}
		initStrBilder.WriteString("\nfunc init() {\n")
		for _, msg := range allMsgs {
			initStrBilder.WriteString(fmt.Sprintf("   msgstore.RegisterMsg(\"%s\", get%s)\n", msg, msg))
		}
		initStrBilder.WriteString("}\n")

		protoFileContent = protoFileContent + initStrBilder.String()

		genFile := &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(rpcFilePath),
			Content: proto.String(protoFileContent),
		}

		genFiles = append(genFiles, genFile)

	}
	return
}

func genFieldProtoMsg(msg *descriptorpb.DescriptorProto, fields []*descriptorpb.FieldDescriptorProto) string {
	r := ""
	if len(fields) == 0 {
		return r
	}
	r += fmt.Sprintf(`
func (x *%s) FieldProtoMsg(fieldName string) (proto.Message,bool) {
   switch fieldName {
`, msg.GetName())

	for _, field := range fields {
		fieldTypeName := extractFieldMsgTypeName(msg, field)
		r += fmt.Sprintf(`   case "%s":
         return &%s{}, true
`, field.GetName(), fieldTypeName)
	}
	r += `	}
	return nil, false
}
`

	return r
}

func extractFieldMsgTypeName(msg *descriptorpb.DescriptorProto, field *descriptorpb.FieldDescriptorProto) string {
	fieldTypeNameFull := field.GetTypeName()
	posLastDot := strings.LastIndex(fieldTypeNameFull, ".")
	if posLastDot == -1 {
		return fieldTypeNameFull
	}
	fieldTypeName := fieldTypeNameFull[posLastDot+1:]
	return fieldTypeName

}

func getGoSubPackage(goPackage string, protoPackage string) string {
	if len(goPackage) == 0 {
		return protoPackage
	}
	//split by / and get last one
	goPackageList := strings.Split(goPackage, "/")
	return goPackageList[len(goPackageList)-1]
}
